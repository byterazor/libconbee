/*
 * This file is part of the libconbee library distribution (https://gitcloud.federationhq.de/byterazor/libconbee)
 * Copyright (c) 2019 Dominik Meyer <dmeyer@federationhq.de>.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

 /** @file */
 
#include <slip.h>
#include <conbee.h>


/**
* @brief transmit one frame of binary data using the slip encoding scheme
*
* the user has to make sure that the buffer really has the number of given bytes,
* otherwise a memory error will occur!
*
* @param dev    - pointer to a conbee_device structure, please make memory is already allocated
* @param buffer - the buffer holding the frame
* @param length - the number of bytes to transmit/ the length of the frame in bytes
*
* @return -1  - something went terribly wrong
* @return >=0 - the number of bytes transmitted
*/
int slip_transmit_packet(struct conbee_device *dev, uint8_t *buffer, uint32_t length)
{
  // variable for checking for errors in calls to write_byte
  int err = 0;

  /*
  * most of the following code is taken from the SLIP RFC (RFC 1055)
  * https://tools.ietf.org/html/rfc1055
  */

  err=dev->write_byte(dev,END);

  while(length--)
  {
    switch(*buffer)
    {
      case END:
                err=dev->write_byte(dev,ESC);
                if(err < 0)
                {
                  break;
                }

                err=dev->write_byte(dev,ESC_END);
                break;

      case ESC:
                err=dev->write_byte(dev,ESC);
                if(err < 0)
                {
                  break;
                }

                err=dev->write_byte(dev,ESC_ESC);
                break;

      default:
                err=dev->write_byte(dev,*buffer);
    };

    buffer++;
  }


  dev->write_byte(dev,END);

  return err;
}


/**
* @brief transmit one frame of binary data using the slip encoding scheme
*
* the user has to make sure that the buffer really has the number of given bytes,
* otherwise a memory error will occur!
*
* @param dev    - pointer to a conbee_device structure, please make memory is already allocated
* @param buffer - the buffer saving the frame to
* @param length - the number of bytes to receive at maximum/ the length of the frame buffer in bytes
*
* @return -1  - something went terribly wrong
* @return >=0 - the number of bytes received
*/
int slip_receive_packet(struct conbee_device *dev, uint8_t *buffer, uint32_t length)
{
  // for reading one byte
  uint8_t c = 0;

  // errors coming from read_byte
  uint32_t err = 0;

  // the number of received bytes
  uint32_t received = 0;

  /*
  * most of the following code is taken from the SLIP RFC (RFC 1055)
  * https://tools.ietf.org/html/rfc1055
  */
  while(1) {
    // get us one byte from the physical layer
    err = dev->read_byte(dev,&c);

    // if an error occured return immediatly
    if(err < 0 )
    {
      return err;
    }

    switch(c)
    {
      case END:
               /* a minor optimization: if there is no
                * data in the packet, ignore it. This is
                * meant to avoid bothering IP with all
                * the empty packets generated by the
                * duplicate END characters which are in
                * turn sent to try to detect line noise.
                */
               if(received)
                       return received;
               else
                       break;

       /* if it's the same code as an ESC character, wait
       * and get another character and then figure out
       * what to store in the packet based on that.
       */
      case ESC:
              err = dev->read_byte(dev,&c);

              // if an error occured return immediatly
              if(err < 0 )
              {
                return err;
              }

              /* if "c" is not one of these two, then we
               * have a protocol violation.  The best bet
               * seems to be to leave the byte alone and
               * just stuff it into the packet
               */
              switch(c)
              {

                case ESC_END:
                        c = END;
                        break;
                case ESC_ESC:
                        c = ESC;
                        break;
              }

     /* here we fall into the default handler and let
      * it store the character for us
      */
     default:
             if(received < length)
             {
               buffer[received++] = c;
             }
    }


  }



}
